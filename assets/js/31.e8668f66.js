(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{385:function(t,e,o){"use strict";o.r(e);var n=o(42),v=Object(n.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"vuex入门"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#vuex入门"}},[t._v("#")]),t._v(" Vuex入门")]),t._v(" "),o("h2",{attrs:{id:"什么是vuex"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是vuex"}},[t._v("#")]),t._v(" 什么是vuex")]),t._v(" "),o("p",[t._v("vuex是一个专门为vue.js应用程序开的状态管理模式\n它采用集中式存储管理应用的所有组件的状态\n并以相应的规则保证以一种可预测的方式发生变化\n总结：vuex 就是类似于全局对象存储的所有组件里面的状态，并且是个响应式的状态")]),t._v(" "),o("h2",{attrs:{id:"应用场景"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),o("p",[t._v("1、多个视图依赖于同一状态\n2、来自不同视图的行为需要改变同一状态\n总结：\na)  不同的组件都依赖于同一个数据状态，实现了多个组件数据共享的作用（读）（如用户登陆）\nb)  在不同的组建中，需要一些操作来改变数据状态（改）（如购买会员）\nc)  比较适合中、大型的前端单页面项目，不适用小的")]),t._v(" "),o("h2",{attrs:{id:"组成介绍"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#组成介绍"}},[t._v("#")]),t._v(" 组成介绍")]),t._v(" "),o("p",[t._v("State --数据仓库，所有的数据都存储于state中，数据唯一源（存储vue所有状态数据），属于 json 对象"),o("br"),t._v("\ngetter --用来获取数据的，相当于vue的computed"),o("br"),t._v("\nMutation -- 用来修改数据的，本质相当于一个function。数据一定要写成同步的"),o("br"),t._v("\nAction --用来提交mutation数据，可以异步提交")]),t._v(" "),o("h2",{attrs:{id:"安装"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[t._v("#")]),t._v(" 安装")]),t._v(" "),o("p",[t._v("安装vuex\n安装vuex包：npm install vuex\n创建vuex实例：new Vuex.store()")]),t._v(" "),o("p",[t._v("main.js中将vuex实例挂载到vue对象上")]),t._v(" "),o("p",[t._v("vuex是vue的一个重要知识点\n要先安装 vue-cli （脚手架）才可以")]),t._v(" "),o("p",[t._v("vue create vuex-demo")]),t._v(" "),o("p",[t._v("code . 命令用不了，好像需要vscode，安装一个吧，以后开发用得上\n感谢：mac vscode 下载安装与配置 https://www.jianshu.com/p/90d83f81b78a\n然后，感谢 mac vscode -bash: code: command not found https://blog.csdn.net/qq_27848323/article/details/105739272\n安装了这个命令之后，可以通过 code . 打开了。")]),t._v(" "),o("p",[t._v("我可以在本地起服务了！Woooooooooooooo~\ncd进入可以起服务的项目文件夹，然后运行 npm run serve")]),t._v(" "),o("p",[t._v("在chrome用vue tool调试，我已经安装了")]),t._v(" "),o("p",[t._v("另起一个在该文件夹位置的终端窗口，输入 npm add vuex")]),t._v(" "),o("p",[t._v("很多错误都是不起眼的错误，注意拼写和大小写T_Ts")]),t._v(" "),o("h2",{attrs:{id:"实现count"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#实现count"}},[t._v("#")]),t._v(" 实现count++")]),t._v(" "),o("p",[t._v("实现count++，demo基本思路")]),t._v(" "),o("ol",[o("li",[t._v("state 中创建 count 字段")]),t._v(" "),o("li",[t._v("mutation 中创建一个 count++ 的 mutation")]),t._v(" "),o("li",[t._v("button 新增 click 事件触发，触发 mutation ，改变 count")])]),t._v(" "),o("p",[t._v("注释组件时，报错了，原来是——引用组件不使用就会报错"),o("br"),t._v(" "),o("a",{attrs:{href:"https://www.imooc.com/qadetail/335252",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.imooc.com/qadetail/335252"),o("OutboundLink")],1),o("br"),t._v("\n解决："),o("br"),t._v("\n是 eslint 代码检查到你注册了组件但没有使用，然后就报错了。你可以在package.json文件中"),o("br"),t._v('\neslintConfig 字段下的 rules 添加规则 "vue/no-unused-components": "off" 就可以解决这个问题')]),t._v(" "),o("p",[t._v("看到的问答，一知半解，呜呜呜呜呜：\n问题：\n为什么在组件中我们获取vuex中的实例的count值时，还需要用this,在veiw模板中直接填值，不是直接就行了；\n老师解答：\n第一种，如果是你是直接获取vuex store实例，首先Vue.use(Vuex)就已经吧 store类的实例挂载到 最外层Vue实例上了，所以需要this.$store就能沿着作用域链获取 store类的实例\n第二种，如果借助 vuex的 mapstate等辅助函数方式，结果是把 store里面的数据以computed,或者methods呈现，此时的 this.count 实际是指向的computed放回的值\n第三种， 如果你是用moudel形式直接引入store类的实例，就不需要this, 方式\nimport store from ''/src/store.js\nscript中 可以直接 store.state.count 获取count的值")])])}),[],!1,null,null,null);e.default=v.exports}}]);